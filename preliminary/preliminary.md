编程是在既定的规则下解决问题。
编程是设计算法然后付诸实践的过程。



编程的学习实际上是规则的学习，n重循环需要用递归 call for 递归论

要把执行从设计理念中解耦出来，也就是我们要先忽视复杂度相关的问题
我们不关心一个方案具体是怎么落实的，我们关心方案是否是可行的
par exemple：排队时我们不关心具体每个人前面站着谁，我们关注的是「每个人都比他前一个人要高」这个性质

程序的理解是功能性的而不是执行性的

有必要提及 hardware 吗

我们应该先让学生学会描述他已经会了的东西，而不是学习新东西和大工程
不要拘泥于语法
我们应该提供的是相应编程语言的一个自然的完备子集

可靠的

不可靠容易造成 overgeneralisation 问题

计算模型 算法 算法复杂度

非构造性的
特定计算模型的计算能力
特定计算模型在特定复杂度下的计算能力

构造性的
算法的设计
算法的实现

不谈计算模型的弊端？过度依赖具体的程序设计语言和场景

程序设计语言的学习和自然语言的学习
学习目的：表达自己的观点（日常说话），学会表达自己的观点（写作文）
par exemple：搭书塔，最顶层可以随便摆摆
允许学生基于不同的学习目标
允许学生 not decide 学习目标

static single-assignment form

查漏补缺
系统化学习

太依赖 interpreter 以致于拘泥于具体的程序设计语言